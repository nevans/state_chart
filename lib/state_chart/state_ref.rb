# frozen_string_literal: true

require_relative "util"
require_relative "errors"

module StateChart

  # A string reference to a {State} either by {State#id} or by {State#path}
  # (relative or absolute).  Can be resolved to a {State}, by providing a
  # referring {Chart} or {State}.
  #
  # When defined with an unprefixed string, resolution will first look up by ID.
  # If that doesn't work, it will attempt look up by (dot-delimited) key path,
  # starting with this node's children, then with siblings (the parent node's
  # children), then with the grandparent node's children, and so on all the way
  # up to the root {Chart} node.
  #
  # Or the reference can use a prefix to enforce a specific resolution type.
  # This isn't necessary for ID strings because they are always resolved first,
  # but it may still be useful for clarity or to raise an error if the ID
  # doesn't exist (but maybe the path does!).
  #
  # * `#ID"`            - only select by ID (can use autogenerated ID)
  # * `.`               - self
  # * `.child.path`     - traverse path from current node
  # * `..'              - parent
  # * `..sibling.path`  - traverse path from parent node
  # * `...'             - grandparent
  # * `...aunt.path`    - traverse path from grandparent node
  # * `....'            - great-grandparent
  # # `....and.so.on`   - traverse path from great-grandparent node
  #
  # Alternatively, you can use "/" delimited paths:
  #
  # * `./child/path`
  # * `../sibling/path`
  # * `../..` (grandparent)
  # * `../../path/to/cousins`
  # * `/path/from/root` - dotted paths can't enforce path traversal from root
  #
  class StateRef

    attr_reader :reference
    alias ref reference
    alias to_s reference

    def self.resolved(reference, referrer:)
      new(reference).resolve_from(referrer)
    end

    def self.[](ref) new(ref) end

    def initialize(reference)
      unless Util::Regex::VALID_REF.match?(reference)
        raise InvalidName, "invalid State reference: %p" % [reference]
      end
      @reference = -reference.to_s
      freeze
    end

    def resolve_from(referrer)
      if self?
        referrer
      elsif defined_as_id?
        id = @reference[1..-1]
        referrer.chart[id]
      elsif defined_as_relative_path?
        referrer.dig(*path_segments)
      elsif defined_as_absolute_path?
        referrer.chart.dig(*path_segments)
      else
        referrer.chart[@reference] || search_up_for_path(referrer)
      end
        .tap {|state| guard_valid_ref!(state) }
    end

    def defined_as_id?;            @reference.start_with?("#") end
    def defined_as_relative_path?; @reference.start_with?(".") end
    def defined_as_absolute_path?; @reference.start_with?("/") end
    def defined_as_any?;          !@reference.match?(%r{\A[#./]}) end

    SELF   = "."
    PARENT = ".."

    def self?; @reference == SELF end
    alias this? self?

    def parent?; @reference == PARENT end
    def ancestor?; @reference.match?(Util::Regex::ANCESTOR_REF) end

    def slash_delimited?; @reference.include?("/") end
    def dot_delimited?; !slash_delimited? end

    def path_segments
      case @reference
      when SELF;   SELF_SEGMENT
      when PARENT; PARENT_SEGMENT
      when Util::Regex::DOT_DELIMITED_PATH
        first, *dig_down = @reference.scan(Util::Regex::DOT_DELIMITED_SCAN)
        dotted_ancestor_segments(first) + dig_down
      when Util::Regex::SLASH_DELIMITED_PATH
        first, *rest = reference.split("/")
        first.empty? ? rest : [first, *rest]
      end
    end

    private

    SELF_SEGMENT = [SELF].freeze
    private_constant :SELF_SEGMENT

    PARENT_SEGMENT = [PARENT].freeze
    private_constant :PARENT_SEGMENT

    def dotted_ancestor_segments(dots)
      case dots
      when "";     Util::EMPTY
      when SELF;   SELF_SEGMENT
      when PARENT; PARENT_SEGMENT
      when /^[^.]/; [dots]
      else
        (PARENT_SEGMENT * (dots.length - 1))
          .map { -_1 }.freeze
      end
    end

    def search_up_for_path(node)
      current = node
      path = path_segments
      while current
        found = current.dig(*path)
        return found if found
        current = current.parent
      end
      nil
    end

    def guard_valid_ref!(state)
      unless state.is_a?(State)
        raise InvalidReference, "Invalid StateRef[%p] => %p" % [ref, state]
      end
    end

  end

end
